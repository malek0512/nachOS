ETAPE 1:
--------
2.2 Initialisation du systeme

Le code de la foncton initialise() : bin/main.c
Indiquer sur le schema : Y'en a pas. En gros faut dire que le c++ correspond au code executé sur notre machine linux, tandis que le code C correspond au code de la machine simulé tournant sur un processeur MISP de simulation
Voir le code de la classe machine.cc (.h) 

Thread.cc : 
Comment est crée le premier thread :

Sa pile et registres vient de la classe machine.cc

Le role futur de la structure de donnée allouée par currentThread = new Thread("main") :
* On partage un mm espace d'adressage
* Moins lourd de creer un thread qu'un process
le thread est executé : 
C'est du c++ donc c'est du code executer par la machine linux acer personnelle

2.3 : 
Dans machine.h : mainMemory represente la memoire physique du programme
Les registres sont initialisé dans le contructeur de machine.cc
On verifie que startProcess est appelé avec halt() puisque c'est argv +1 qu'on lui passe en parametre après une itération de la boucle for

3.1 :
La premiere instruction est au 10e tick d'horloge, car on execute un pgm utilisateur, donc toute la partie initialisation n'est pas visible

3.2 : 
Nous creons un nouveau thread, en editant la fonciton ThreadTest(), et ca ne compile plus si nous touchons a l'arguement de la fonction.
Nous remarquons que les thread s'execute dans un ordre fifo


3.5 :
malek-Aspire-V5-471PG:/media/malek/g/workspace/nachOS/code/build
$ ./nachos-threads -rs 5 -d +
Scheduling interrupt handler the timer at time = 76
        interrupts: off -> on

== Tick 10 ==
        interrupts: on -> off
Time: 10, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
Entering SimpleTest
Forking thread "forked thread" with func = 0x804b08c, arg = 0
        interrupts: on -> off
Putting thread forked thread on ready list.
        interrupts: off -> on

== Tick 20 ==
        interrupts: on -> off
Time: 20, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
Forking thread "forked2 thread" with func = 0x804b0d3, arg = 1
        interrupts: on -> off
Putting thread forked2 thread on ready list.
        interrupts: off -> on

== Tick 30 ==
        interrupts: on -> off
Time: 30, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
        interrupts: on -> off
Finishing thread "main"
Sleeping thread "main"
Switching from thread "main" to thread "forked thread"
Deleting thread "main"
        interrupts: off -> on

== Tick 40 ==
        interrupts: on -> off
Time: 40, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
*** thread 0 looped 0 times
        interrupts: on -> off
Yielding thread "forked thread"
        interrupts: off -> on

== Tick 50 ==
        interrupts: on -> off
Time: 50, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
*** thread 0 looped 1 times
        interrupts: on -> off
Yielding thread "forked thread"
Putting thread forked thread on ready list.
Switching from thread "forked thread" to thread "forked2 thread"
        interrupts: off -> on

== Tick 60 ==
        interrupts: on -> off
Time: 60, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
*** thread 1 looped 0 times
--
        interrupts: on -> off
Yielding thread "forked2 thread"
        interrupts: off -> on

== Tick 70 ==
        interrupts: on -> off						@ A quoi ca correspond ????
Time: 70, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts
        interrupts: off -> on
*** thread 1 looped 1 times						@ Exectution du corp de la fonction du thread
--
        interrupts: on -> off						@ C'est pour le Yield
Yielding thread "forked2 thread"
Putting thread forked2 thread on ready list.
Switching from thread "forked2 thread" to thread "forked thread"
Now in thread "forked thread"
        interrupts: off -> on

== Tick 80 ==
        interrupts: on -> off
Time: 80, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0a0)
Interrupt handler timer, scheduled at 76
End of pending interrupts

Invoking interrupt handler for the timer at time 76				@A quoi ca correpond c'est nouveau !!!
Scheduling interrupt handler the timer at time = 246
Time: 80, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
        interrupts: on -> off
Yielding thread "forked thread"
        interrupts: off -> on

== Tick 90 ==
        interrupts: on -> off
Time: 90, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 0 looped 2 times
        interrupts: on -> off
Yielding thread "forked thread"
Putting thread forked thread on ready list.
Switching from thread "forked thread" to thread "forked2 thread"
Now in thread "forked2 thread"
        interrupts: off -> on

== Tick 100 ==
        interrupts: on -> off
Time: 100, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 1 looped 2 times
--
        interrupts: on -> off
Yielding thread "forked2 thread"
        interrupts: off -> on

== Tick 110 ==
        interrupts: on -> off
Time: 110, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 1 looped 3 times
--
        interrupts: on -> off
Yielding thread "forked2 thread"
Putting thread forked2 thread on ready list.
Switching from thread "forked2 thread" to thread "forked thread"
Now in thread "forked thread"
        interrupts: off -> on

== Tick 120 ==
        interrupts: on -> off
Time: 120, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 0 looped 3 times
        interrupts: on -> off
Yielding thread "forked thread"
        interrupts: off -> on

== Tick 130 ==
        interrupts: on -> off
Time: 130, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 0 looped 4 times
        interrupts: on -> off
Yielding thread "forked thread"
Putting thread forked thread on ready list.
Switching from thread "forked thread" to thread "forked2 thread"
Now in thread "forked2 thread"
        interrupts: off -> on

== Tick 140 ==
        interrupts: on -> off
Time: 140, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
*** thread 1 looped 4 times
--
        interrupts: on -> off
Yielding thread "forked2 thread"
        interrupts: off -> on

== Tick 150 ==
        interrupts: on -> off
Time: 150, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
        interrupts: on -> off
Finishing thread "forked2 thread"
Sleeping thread "forked2 thread"
Switching from thread "forked2 thread" to thread "forked thread"
Now in thread "forked thread"
Deleting thread "forked2 thread"
        interrupts: off -> on

== Tick 160 ==
        interrupts: on -> off
Time: 160, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
        interrupts: off -> on
        interrupts: on -> off
Finishing thread "forked thread"
Sleeping thread "forked thread"
Machine idling; checking for interrupts.
Time: 160, interrupts off
Pending interrupts:
In mapcar, about to invoke 804933f(88bd0b8)
Interrupt handler timer, scheduled at 246
End of pending interrupts
Machine idle.  No interrupts to do.
No threads ready or runnable, and no pending interrupts.
Assuming the program completed.
Machine halting!

Ticks: total 246, idle 86, system 160, user 0
Disk I/O: reads 0, writes 0
Console I/O: reads 0, writes 0
Paging: faults 0
Network I/O: packets received 0, sent 0

Cleaning up...

********************************************************************************************************************************************

(gdb) s
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) s
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:202
202         ASSERT (this == currentThread);
(gdb) 
204         DEBUG ('t', "Yielding thread \"%s\"\n", getName ());
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:72
72      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:206
206         if (((++cpt) % 2) == 0) {
(gdb) 
207             cpt = 0;
(gdb) 
208             nextThread = scheduler->FindNextToRun ();
(gdb) 
Scheduler::FindNextToRun (this=0x804f070) at ../threads/scheduler.cc:73
73          return (Thread *) readyList->Remove ();
(gdb) 
List::Remove (this=0x804f080) at ../threads/list.cc:133
133         return SortedRemove (NULL); // Same as SortedRemove, but ignore the key
(gdb) 
List::SortedRemove (this=0x804f080, keyPtr=0x0) at ../threads/list.cc:234
234         ListElement *element = first;
(gdb) 
237         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f080) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
167             return FALSE;
(gdb) 
168     }
(gdb) 
List::SortedRemove (this=0x804f080, keyPtr=0x0) at ../threads/list.cc:240
240         thing = first->item;
(gdb) 
241         if (first == last)
(gdb) 
243               first = NULL;
(gdb) 
244               last = NULL;
(gdb) 
250         if (keyPtr != NULL)
(gdb) 
252         delete element;
(gdb) 
253         return thing;
(gdb) 
254     }
(gdb) 
List::Remove (this=0x804f080) at ../threads/list.cc:134
134     }
(gdb) 
Scheduler::FindNextToRun (this=0x804f070) at ../threads/scheduler.cc:74
74      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:209
209             if (nextThread != NULL)
(gdb) 
211                       scheduler->ReadyToRun (this);
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:56
56          DEBUG ('t', "Putting thread %s on ready list.\n", thread->getName ());
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804b7f4 "Putting thread %s on ready list.\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804b7f4 "Putting thread %s on ready list.\n") at ../threads/utility.cc:72
72      }
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:58
58          thread->setStatus (READY);
(gdb) 
Thread::setStatus (this=0x804f190, st=READY) at ../threads/thread.h:105
105             status = st;
(gdb) 
106         }
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:59
59          readyList->Append ((void *) thread);
(gdb) 
List::Append (this=0x804f080, item=0x804f190) at ../threads/list.cc:79
79          ListElement *element = new ListElement (item, 0);
(gdb) 
ListElement::ListElement (this=0x805b218, itemPtr=0x804f190, sortKey=0) at ../threads/list.cc:32
32          item = itemPtr;
(gdb) 
33          key = sortKey;
(gdb) r -rs 5
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /media/malek/g/workspace/nachOS/code/build/nachos-threads -rs 5
*** thread 0 looped 0 times

Breakpoint 1, Thread::Yield (this=0x804f130) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);
(gdb) c
Continuing.
*** thread 0 looped 1 times

Breakpoint 1, Thread::Yield (this=0x804f130) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);
(gdb) c
Continuing.
*** thread 1 looped 0 times
--

Breakpoint 1, Thread::Yield (this=0x804f190) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);
(gdb) s
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) 
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:202
202         ASSERT (this == currentThread);
(gdb) 
204         DEBUG ('t', "Yielding thread \"%s\"\n", getName ());
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:72
72      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:206
206         if (((++cpt) % 2) == 0) {
(gdb) 
217         (void) interrupt->SetLevel (oldLevel);
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) 
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
128             OneTick();                              // advance simulated time
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:156
156         MachineStatus old = status;
(gdb) 
159         if (status == SystemMode) {
(gdb) 
160             stats->totalTicks += SystemTick;
(gdb) 
161             stats->systemTicks += SystemTick;
(gdb) 
166         DEBUG('i', "\n== Tick %d ==\n", stats->totalTicks);
(gdb) 
DEBUG (flag=105 'i', format=0x804b5ae "\n== Tick %d ==\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b5ae "\n== Tick %d ==\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:169
169         ChangeLevel(IntOn, IntOff);         // first, turn off interrupts
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:172
172         while (CheckIfDue(FALSE))           // check for pending interrupts
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:296
296         MachineStatus old = status;
(gdb) 
299         ASSERT(level == IntOff);            // interrupts need to be disabled,
(gdb) 
301         if (DebugIsEnabled('i'))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:304
304                     (PendingInterrupt *)pending->SortedRemove(&when);
(gdb) 
List::SortedRemove (this=0x804f060, keyPtr=0x805a108) at ../threads/list.cc:234
234         ListElement *element = first;
(gdb) 
237         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f060) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
167             return FALSE;
(gdb) 
168     }
(gdb) 
List::SortedRemove (this=0x804f060, keyPtr=0x805a108) at ../threads/list.cc:240
240         thing = first->item;
(gdb) 
241         if (first == last)
(gdb) 
243               first = NULL;
(gdb) 
244               last = NULL;
(gdb) 
250         if (keyPtr != NULL)
(gdb) 
251             *keyPtr = element->key;
(gdb) 
252         delete element;
(gdb) 
253         return thing;
(gdb) 
254     }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:306
306         if (toOccur == NULL)                // no pending interrupts
(gdb) 
309         if (advanceClock && when > stats->totalTicks) {     // advance the clock
(gdb) 
312         } else if (when > stats->totalTicks) {      // not time yet, put it back
(gdb) 
313             pending->SortedInsert(toOccur, when);
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0a0, sortKey=76) at ../threads/list.cc:188
188         ListElement *element = new ListElement (item, sortKey);
(gdb) 
ListElement::ListElement (this=0x804f0b8, itemPtr=0x804f0a0, sortKey=76) at ../threads/list.cc:32
32          item = itemPtr;
(gdb) 
33          key = sortKey;
(gdb) 
34          next = NULL;                // assume we'll put it at the end of the list 
(gdb) 
35      }
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0a0, sortKey=76) at ../threads/list.cc:191
191         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f060) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
165             return TRUE;
(gdb) 
168     }
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0a0, sortKey=76) at ../threads/list.cc:193
193               first = element;
(gdb) 
194               last = element;
(gdb) 
216     }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:314
314             return FALSE;
(gdb) 
339     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:174
174         ChangeLevel(IntOff, IntOn);         // re-enable interrupts
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:175
175         if (yieldOnReturn) {                // if the timer device handler asked 
(gdb) 
182     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:129
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:218
218     }
(gdb) 
SimpleThread2 (which=1) at ../threads/threadtest.cc:39
39          for(i=0; i<5; i++) { 
(gdb) 
40            printf ("*** thread %d looped %d times\n", which, i);
(gdb) 
*** thread 1 looped 1 times
41            printf ("--\n");
(gdb) 
--
42                currentThread->Yield ();
(gdb) 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Premier Yield CA NE PEUT PAS 
ETRE L'APPEL YIELD DE LA FONCTION CAR IL EST SUIVI D'UN YIELD ET PAS D'AFFICHAGE A LA FIN DE CE YIELD

Breakpoint 1, Thread::Yield (this=0x804f190) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) 
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:202
202         ASSERT (this == currentThread);
(gdb) 
204         DEBUG ('t', "Yielding thread \"%s\"\n", getName ());
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:72
72      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:206
206         if (((++cpt) % 2) == 0) {
(gdb) 
207             cpt = 0;
(gdb) 
208             nextThread = scheduler->FindNextToRun ();
(gdb) 
Scheduler::FindNextToRun (this=0x804f070) at ../threads/scheduler.cc:73
73          return (Thread *) readyList->Remove ();
(gdb) 
List::Remove (this=0x804f080) at ../threads/list.cc:133
133         return SortedRemove (NULL); // Same as SortedRemove, but ignore the key
(gdb) 
List::SortedRemove (this=0x804f080, keyPtr=0x0) at ../threads/list.cc:234
234         ListElement *element = first;
(gdb) 
237         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f080) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
167             return FALSE;
(gdb) 
168     }
(gdb) 
List::SortedRemove (this=0x804f080, keyPtr=0x0) at ../threads/list.cc:240
240         thing = first->item;
(gdb) 
241         if (first == last)
(gdb) 
243               first = NULL;
(gdb) 
244               last = NULL;
(gdb) 
250         if (keyPtr != NULL)
(gdb) 
252         delete element;
(gdb) 
253         return thing;
(gdb) 
254     }
(gdb) 
List::Remove (this=0x804f080) at ../threads/list.cc:134
134     }
(gdb) 
Scheduler::FindNextToRun (this=0x804f070) at ../threads/scheduler.cc:74
74      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:209
209             if (nextThread != NULL)
(gdb) 
211                       scheduler->ReadyToRun (this);
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:56
56          DEBUG ('t', "Putting thread %s on ready list.\n", thread->getName ());
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804b7f4 "Putting thread %s on ready list.\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804b7f4 "Putting thread %s on ready list.\n") at ../threads/utility.cc:72
72      }
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:58
58          thread->setStatus (READY);
(gdb) 
Thread::setStatus (this=0x804f190, st=READY) at ../threads/thread.h:105
105             status = st;
(gdb) 
106         }
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:59
59          readyList->Append ((void *) thread);
(gdb) 
List::Append (this=0x804f080, item=0x804f190) at ../threads/list.cc:79
79          ListElement *element = new ListElement (item, 0);
(gdb) 
ListElement::ListElement (this=0x805b218, itemPtr=0x804f190, sortKey=0) at ../threads/list.cc:32
32          item = itemPtr;
(gdb) 
33          key = sortKey;
(gdb) 
34          next = NULL;                // assume we'll put it at the end of the list 
(gdb) 
35      }
(gdb) 
List::Append (this=0x804f080, item=0x804f190) at ../threads/list.cc:81
81          if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f080) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
165             return TRUE;
(gdb) 
168     }
(gdb) 
List::Append (this=0x804f080, item=0x804f190) at ../threads/list.cc:83
83                first = element;
(gdb) 
84                last = element;
(gdb) 
91      }
(gdb) 
Scheduler::ReadyToRun (this=0x804f070, thread=0x804f190) at ../threads/scheduler.cc:60
60      }
(gdb) 
Thread::Yield (this=0x804f190) at ../threads/thread.cc:212
212                       scheduler->Run (nextThread);
(gdb) 
Scheduler::Run (this=0x804f070, nextThread=0x804f130) at ../threads/scheduler.cc:93
93          Thread *oldThread = currentThread;
(gdb) 
96          ASSERT (interrupt->getLevel () == IntOff);
(gdb) 
Interrupt::getLevel (this=0x804f048) at ../machine/interrupt.h:87
87          IntStatus getLevel() {return level;}// Return whether interrupts
(gdb) 
Scheduler::Run (this=0x804f070, nextThread=0x804f130) at ../threads/scheduler.cc:107
107         oldThread->CheckOverflow ();        // check if the old thread
(gdb) 
Thread::CheckOverflow (this=0x804f190) at ../threads/thread.cc:136
136         if (stack != NULL)
(gdb) 
140             ASSERT (*stack == (int) STACK_FENCEPOST);
(gdb) 
142     }
(gdb) 
Scheduler::Run (this=0x804f070, nextThread=0x804f130) at ../threads/scheduler.cc:110
110         currentThread = nextThread; // switch to the next thread
(gdb) 
111         currentThread->setStatus (RUNNING); // nextThread is now running
(gdb) 
Thread::setStatus (this=0x804f130, st=RUNNING) at ../threads/thread.h:105
105             status = st;
(gdb) 
106         }
(gdb) 
Scheduler::Run (this=0x804f070, nextThread=0x804f130) at ../threads/scheduler.cc:114
114                oldThread->getName (), nextThread->getName ());
(gdb) 
Thread::getName (this=0x804f130) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
Thread::getName (this=0x804f190) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804b858 "Switching from thread \"%s\" to thread \"%s\"\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804b858 "Switching from thread \"%s\" to thread \"%s\"\n") at ../threads/utility.cc:72
72      }
(gdb) 
Scheduler::Run (this=0x804f070, nextThread=0x804f130) at ../threads/scheduler.cc:121
121         SWITCH (oldThread, nextThread);
(gdb) 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEUXIEME   YIELD NON PRECEDE D'UN PRINTF

Breakpoint 1, Thread::Yield (this=0x804f130) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) 
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOff) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f130) at ../threads/thread.cc:202
202         ASSERT (this == currentThread);
(gdb) 
204         DEBUG ('t', "Yielding thread \"%s\"\n", getName ());
(gdb) 
Thread::getName (this=0x804f130) at ../threads/thread.h:109
109             return (name);
(gdb) 
110         }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=116 't') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=116 't', format=0x804bb77 "Yielding thread \"%s\"\n") at ../threads/utility.cc:72
72      }
(gdb) 
Thread::Yield (this=0x804f130) at ../threads/thread.cc:206
206         if (((++cpt) % 2) == 0) {
(gdb) 
217         (void) interrupt->SetLevel (oldLevel);
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:120
120         IntStatus old = level;
(gdb) 
122         ASSERT((now == IntOff) || (inHandler == FALSE));// interrupt handlers are 
(gdb) 
126         ChangeLevel(old, now);                      // change to new state
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:127
127         if ((now == IntOn) && (old == IntOff))
(gdb) 
128             OneTick();                              // advance simulated time
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:156
156         MachineStatus old = status;
(gdb) 
159         if (status == SystemMode) {
(gdb) 
160             stats->totalTicks += SystemTick;
(gdb) 
161             stats->systemTicks += SystemTick;
(gdb) 
166         DEBUG('i', "\n== Tick %d ==\n", stats->totalTicks);
(gdb) 
DEBUG (flag=105 'i', format=0x804b5ae "\n== Tick %d ==\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b5ae "\n== Tick %d ==\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:169
169         ChangeLevel(IntOn, IntOff);         // first, turn off interrupts
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOn, now=IntOff) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:172
172         while (CheckIfDue(FALSE))           // check for pending interrupts
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:296
296         MachineStatus old = status;
(gdb) 
299         ASSERT(level == IntOff);            // interrupts need to be disabled,
(gdb) 
301         if (DebugIsEnabled('i'))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:304
304                     (PendingInterrupt *)pending->SortedRemove(&when);
(gdb) 
List::SortedRemove (this=0x804f060, keyPtr=0x8054058) at ../threads/list.cc:234
234         ListElement *element = first;
(gdb) 
237         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f060) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
167             return FALSE;
(gdb) 
168     }
(gdb) 
List::SortedRemove (this=0x804f060, keyPtr=0x8054058) at ../threads/list.cc:240
240         thing = first->item;
(gdb) 
241         if (first == last)
(gdb) 
243               first = NULL;
(gdb) 
244               last = NULL;
(gdb) 
250         if (keyPtr != NULL)
(gdb) 
251             *keyPtr = element->key;
(gdb) 
252         delete element;
(gdb) 
253         return thing;
(gdb) 
254     }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:306
306         if (toOccur == NULL)                // no pending interrupts
(gdb) 
309         if (advanceClock && when > stats->totalTicks) {     // advance the clock
(gdb) 
312         } else if (when > stats->totalTicks) {      // not time yet, put it back
(gdb) 
313             pending->SortedInsert(toOccur, when);
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0b8, sortKey=246) at ../threads/list.cc:188
188         ListElement *element = new ListElement (item, sortKey);
(gdb) 
ListElement::ListElement (this=0x80551f8, itemPtr=0x804f0b8, sortKey=246) at ../threads/list.cc:32
32          item = itemPtr;
(gdb) 
33          key = sortKey;
(gdb) 
34          next = NULL;                // assume we'll put it at the end of the list 
(gdb) 
35      }
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0b8, sortKey=246) at ../threads/list.cc:191
191         if (IsEmpty ())
(gdb) 
List::IsEmpty (this=0x804f060) at ../threads/list.cc:164
164         if (first == NULL)
(gdb) 
165             return TRUE;
(gdb) 
168     }
(gdb) 
List::SortedInsert (this=0x804f060, item=0x804f0b8, sortKey=246) at ../threads/list.cc:193
193               first = element;
(gdb) 
194               last = element;
(gdb) 
216     }
(gdb) 
Interrupt::CheckIfDue (this=0x804f048, advanceClock=false) at ../machine/interrupt.cc:314
314             return FALSE;
(gdb) 
339     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:174
174         ChangeLevel(IntOff, IntOn);         // re-enable interrupts
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:102
102         level = now;
(gdb) 
103         DEBUG('i',"\tinterrupts: %s -> %s\n",intLevelNames[old],intLevelNames[now]);
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:63
63          if (DebugIsEnabled (flag))
(gdb) 
DebugIsEnabled (flag=105 'i') at ../threads/utility.cc:47
47          if (enableFlags != NULL)
(gdb) 
48              return (strchr (enableFlags, flag) != 0)
(gdb) 
49                  || (strchr (enableFlags, '+') != 0);
(gdb) 
52      }
(gdb) 
DEBUG (flag=105 'i', format=0x804b557 "\tinterrupts: %s -> %s\n") at ../threads/utility.cc:72
72      }
(gdb) 
Interrupt::ChangeLevel (this=0x804f048, old=IntOff, now=IntOn) at ../machine/interrupt.cc:104
104     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:175
175         if (yieldOnReturn) {                // if the timer device handler asked 
(gdb) 
182     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:129
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f130) at ../threads/thread.cc:218
218     }
(gdb) 
Interrupt::OneTick (this=0x804f048) at ../machine/interrupt.cc:180
180             status = old;
(gdb) 
182     }
(gdb) 
Interrupt::SetLevel (this=0x804f048, now=IntOn) at ../machine/interrupt.cc:129
129         return old;
(gdb) 
130     }
(gdb) 
Thread::Yield (this=0x804f130) at ../threads/thread.cc:218
218     }
(gdb) 
SimpleThread (which=0) at ../threads/threadtest.cc:29
29          for (num = 0; num < 5; num++)
(gdb) 
31                printf ("*** thread %d looped %d times\n", which, num);
(gdb) 
*** thread 0 looped 2 times
32                currentThread->Yield ();

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ YIELD PRECEDE D'UN PRINTF

(gdb) 
Breakpoint 1, Thread::Yield (this=0x804f130) at ../threads/thread.cc:200
200         IntStatus oldLevel = interrupt->SetLevel (IntOff);

*************************************************************************************************************************************************


Etape 2 : 
Prof : 
* Fournir une commande synchrone; (en c le getchar est Asynchrone donc on est pas sûr d'obtenir le caractere voulu).
* Creer de nouveau appel systeme

